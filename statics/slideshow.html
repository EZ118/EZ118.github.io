<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slideshow Agent</title>
    <script src="https://unpkg.com/pptxgenjs@4.0.1/dist/pptxgen.bundle.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
			-webkit-appearance: none!important;
        }

        #app-container {
            display: flex;
            width: 100%;
            height: 100%;
        }

        /* å·¦ä¾§å¹»ç¯ç‰‡åˆ—è¡¨ */
        #slide-list-container {
            width: 200px;
            border-right: 1px solid #ccc;
            overflow-y: auto;
            background-color: #f9f9f9;
            padding: 10px;
        }

        #slide-list {
			border-top: 1px solid #CCC;
            list-style-type: none;
            padding: 5px 0 0 0;
			margin: 5px 0px;
        }

        .slide-item {
            padding: 10px;
            margin-bottom: 5px;
            background-color: #eee;
            cursor: pointer;
			user-select: none;
            border-radius: 8px;
            transition: background-color 0.2s;
        }

        .slide-item:hover {
            background-color: #ddd;
        }

        .slide-item.active {
            background-color: #007bff;
            color: white;
        }
		
        #export-btn {
            width: 100%;
            padding: 10px;
            background-color: #ffc107;
            color: black;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
        }

        #export-btn:hover {
            background-color: #e0a800;
        }

        #new-slide-btn {
            width: 100%;
            padding: 10px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
        }

        #new-slide-btn:hover {
            background-color: #218838;
        }

        /* ä¸­é—´é¢„è§ˆåŒºåŸŸ */
        #preview-container {
            flex: 1;
            padding: 20px;
            overflow: auto;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #slide-preview {
            width: 90%; /* ä¾‹å¦‚ 90% å®½åº¦ */
            height: 80%; /* ä¾‹å¦‚ 80% é«˜åº¦ */
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }

        /* é¢„è§ˆå…ƒç´ æ ·å¼ */
        .preview-element {
            position: absolute;
            box-sizing: border-box;
        }
        .preview-text {
            white-space: pre-wrap; /* ä¿ç•™æ¢è¡Œå’Œç©ºæ ¼ */
            display: flex;
            align-items: center;
        }
        .preview-image {
            object-fit: contain; /* ä¿æŒå›¾ç‰‡æ¯”ä¾‹ */
        }
        .preview-shape {
            /* Shape æ ·å¼ä¸»è¦é€šè¿‡ JS è®¾ç½® */
        }


        /* å³ä¾§ç¼–è¾‘å™¨å’ŒæŒ‰é’® */
        #editor-container {
            width: 400px;
            border-left: 1px solid #ccc;
            display: flex;
            flex-direction: column;
            background-color: #f9f9f9;
        }

        #json-editor {
            flex: 1;
            padding: 10px;
            font-family: monospace;
            font-size: 14px;
            border: none;
            resize: none;
            background-color: #fff;
        }

        #button-container {
            padding: 10px;
            display: flex;
            gap: 10px;
            border-top: 1px solid #ccc;
        }

        .action-btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
        }

        #confirm-btn {
            background-color: #007bff;
            color: white;
			flex-basis: 60%;
        }

        #confirm-btn:hover {
            background-color: #0069d9;
        }

        #delete-btn {
            background-color: #dc3545;
            color: white;
			flex-basis: 30%;
        }

        #delete-btn:hover {
            background-color: #c82333;
        }
		
		#help-btn {
			background-color: #ffc107;
			color: black;
			flex-basis: 10%;
		}
		
		#help-btn:hover {
			background-color: #e0a800;
		}
    </style>
</head>
<body>

<div id="app-container">
    <!-- å·¦ä¾§å¹»ç¯ç‰‡åˆ—è¡¨ -->
    <div id="slide-list-container">
        <button id="export-btn">å¯¼å‡ºä¸º PPTX</button>
        <ul id="slide-list">
            <!-- åˆ—è¡¨é¡¹å°†ç”± JS åŠ¨æ€ç”Ÿæˆ -->
        </ul>
        <button id="new-slide-btn">+ æ–°å»ºå¹»ç¯ç‰‡</button>
    </div>

    <!-- ä¸­é—´é¢„è§ˆåŒºåŸŸ -->
    <div id="preview-container">
        <div id="slide-preview">
            <!-- é¢„è§ˆå†…å®¹å°†ç”± JS åŠ¨æ€ç”Ÿæˆ -->
        </div>
    </div>

    <!-- å³ä¾§ç¼–è¾‘å™¨å’ŒæŒ‰é’® -->
    <div id="editor-container">
        <textarea id="json-editor" placeholder="åœ¨æ­¤è¾“å…¥å¹»ç¯ç‰‡çš„JSONæ•°æ®..."></textarea>
        <div id="button-container">
            <button id="confirm-btn" class="action-btn"> âœ” ç¡®è®¤</button>
            <button id="delete-btn" class="action-btn"> âœ˜ åˆ é™¤</button>
            <button id="help-btn" class="action-btn" title="è·å–å¸®åŠ©"> ? </button>
        </div>
    </div>
	
	<!-- ç”¨äºå­˜å‚¨æç¤ºè¯ -->
	<pre id="reference-prompt-store" style="display:none;">
ä½ æ˜¯ä¸€ä¸ªPPTåˆ¶ä½œåŠ©æ‰‹ï¼Œå·¥ä½œæµç¨‹å¦‚ä¸‹ï¼š
1. **è¯¢é—®ç”¨æˆ·éœ€æ±‚**ï¼šè¯¢é—®ç”¨æˆ·è¯¥ç³»åˆ—å¹»ç¯ç‰‡çš„ä¸»é¢˜ï¼Œå¹¶æ¥å—ä¸»é¢˜ã€è¦æ±‚å’Œå‚è€ƒæ–‡æ¡£ã€‚
2. **æ•°æ®æ£€ç´¢ä¸æ•´ç†**ï¼šæ£€ç´¢ç½‘ç»œæ•°æ®ï¼Œç»“åˆç”¨æˆ·èµ„æ–™å’Œè¦æ±‚ï¼Œåˆ—å‡ºä¸»è¦æ•°æ®å’Œå†…å®¹ã€‚å‘ŠçŸ¥ç”¨æˆ·å¯ä»¥å¼€å§‹ç”ŸæˆPPTï¼ˆâ€œæ•°æ®å·²ç½—åˆ—å®Œæˆï¼Œå¯ä»¥å¼€å§‹å¯¹ç¬¬ä¸€é¡µPPTæå‡ºè¦æ±‚â€ï¼‰ã€‚
3. **ç”Ÿæˆæ¯ä¸€é¡µPPT**ï¼šåœ¨åç»­å¯¹è¯ä¸­ï¼Œç”Ÿæˆæ¯ä¸€é¡µPPTã€‚æ¯ä¸€é¡µä½¿ç”¨JSONæ ¼å¼è¾“å‡ºï¼Œæ ¼å¼éœ€ç®€æ´å¹¶ç”¨ä»£ç å—åŒ…è£¹ï¼Œæ— éœ€æ³¨é‡Šã€‚

### PPTå†…å®¹è¦æ±‚
- æ¯ä¸€é¡µéœ€åŒ…å«æœ¬é¡µä¸»é¢˜çš„å‰¯æ ‡é¢˜ã€‚
- å†…å®¹éœ€å……å®ï¼Œå›¾æ–‡å¹¶èŒ‚ã€‚
- å……åˆ†åˆ©ç”¨å›¾åƒã€æ–‡æœ¬ã€å›¾è¡¨å’Œå›¾å½¢ï¼Œè¥é€ è‰¯å¥½è§†è§‰æ•ˆæœã€‚

### å•é¡µPPTæ ¼å¼å‚è€ƒ
```json
{
	"chart": [
		{
			"type": "area/bar/bar3d/bubble/bubble3d/doughnut/line/pie/radar/scatter",
			"pos": { "x": "10%", "y": "10%", "w": "10%", "h": "10%" },
			"data": {
				"name": "",
				"labels": [],
				"values": []
			}
		}
	],
	"image": [
		{
			"type": "remote",
			"pos": { "x": "10%", "y": "10%", "w": "10%", "h": "10%" },
			"data": "./path/to/image"
		}
	],
	"shape": [
		{
			"type": "rect/ellipse/line",
			"pos": { "x": "10%", "y": "10%", "w": "10%", "h": "10%" },
			"data": {
				"fill": { "type": "solid", "color": "0088CC" },
				"line": { "color": "FF0000", "width": 1, "dashType": "lgDash" },
				"rotate": 180,
				"rectRadius": 0.5,
				"align": "left/center/right"
			}
		}
	],
	"text": [
		{
			"pos": { "x": "10%", "y": "10%", "w": "10%", "h": "10%" },
			"text": "text content",
			"data": {
				"fill": "0088CC",
				"color": "0088CC",
				"fontSize": 256,
				"rotate": 180,
				"bold": true/false,
				"italic": true/false,
				"margin": 99,
				"align": "left/center/right"
			}
		}
	]
}
```
### é‡è¦è¯´æ˜
- æ‰€æœ‰`type`ã€`pos`ã€`data`å†…çš„å€¼å¯ä¿®æ”¹ï¼Œç‰¹åˆ«æ˜¯`pos`ä¸­çš„`x`ã€`y`ã€`w`ã€`h`å¿…é¡»è¢«ä¿®æ”¹ã€‚
- `text`å’Œ`shape`çš„`data`å†…çš„é”®å€¼å¦‚æœé€‰æ‹©é»˜è®¤æˆ–`false`ï¼Œå¯åˆ å»ä¸å†™ã€‚

æ¥ä¸‹æ¥ï¼Œè¯·å¼€å§‹æ¥å—ç”¨æˆ·çš„è¦æ±‚ã€‚</pre>


</div>

<script>
    // --- åº”ç”¨çŠ¶æ€ ---
    let slides = [
        {
            text: [{ pos: { x: "10%", y: "35%", w: "80%", h: "20%" }, text: "æ¬¢è¿ä½¿ç”¨ Slideshow Agent", data: { fontSize: 44, align: "center" } }],
            image: [],
            shape: [],
            chart: []
        }
    ];
    let currentSlideIndex = 0;

    // --- DOM å…ƒç´  ---
    const slideListElement = document.getElementById('slide-list');
    const previewElement = document.getElementById('slide-preview');
    const jsonEditorElement = document.getElementById('json-editor');
    const confirmButton = document.getElementById('confirm-btn');
    const deleteButton = document.getElementById('delete-btn');
    const helpButton = document.getElementById('help-btn');
    const newSlideButton = document.getElementById('new-slide-btn');
    const exportButton = document.getElementById('export-btn');

    // --- åˆå§‹åŒ– ---
    function init() {
        updateSlideList();
        showSlide(currentSlideIndex);
        jsonEditorElement.value = JSON.stringify(slides[currentSlideIndex], null, 2);
    }

    // --- UI æ›´æ–°å‡½æ•° ---
    function updateSlideList() {
        slideListElement.innerHTML = '';
        slides.forEach((slide, index) => {
            const li = document.createElement('li');
            li.textContent = ` ğŸ“Š å¹»ç¯ç‰‡ ${index + 1}`;
            li.classList.add('slide-item');
            if (index === currentSlideIndex) {
                li.classList.add('active');
            }
            li.addEventListener('click', () => selectSlide(index));
            slideListElement.appendChild(li);
        });
    }

    function selectSlide(index) {
        currentSlideIndex = index;
        updateSlideList(); // æ›´æ–°åˆ—è¡¨é¡¹çš„ active çŠ¶æ€
        showSlide(index);
        jsonEditorElement.value = JSON.stringify(slides[index], null, 2);
    }

    function showSlide(index) {
        renderSlidePreview(slides[index]);
    }

    // --- æ ¸å¿ƒé¢„è§ˆæ¸²æŸ“å‡½æ•° ---
    function renderSlidePreview(slideData) {
        previewElement.innerHTML = ''; // æ¸…ç©ºä¹‹å‰çš„é¢„è§ˆ

        if (!slideData) return;
		
		// æ¸²æŸ“ Shape (ç®€åŒ–ä¸ºçŸ©å½¢ã€æ¤­åœ†ã€ç›´çº¿)
        if (slideData.shape && Array.isArray(slideData.shape)) {
            slideData.shape.forEach(s => {
                let shapeElement;
                if (s.type === 'rect') {
                    shapeElement = document.createElement('div');
                } else if (s.type === 'ellipse') {
                     shapeElement = document.createElement('div');
                     shapeElement.style.borderRadius = '50%';
                } else if (s.type === 'line') {
                     shapeElement = document.createElement('div');
                     // ç®€åŒ–å¤„ç†ç›´çº¿ï¼Œå‡è®¾æ˜¯æ°´å¹³æˆ–å‚ç›´çš„
                     shapeElement.style.height = s.data && s.data.line && s.data.line.width ? `${s.data.line.width}px` : '2px';
                     shapeElement.style.width = s.pos.w;
                     shapeElement.style.backgroundColor = s.data && s.data.line && s.data.line.color ? `#${s.data.line.color}` : '#000000';
                     // å¿½ç•¥ dashType ç­‰å¤æ‚æ ·å¼ç®€åŒ–
                }

                if (shapeElement && s.type !== 'line') { // line å·²ç»è®¾ç½®äº†å®½é«˜
                     shapeElement.classList.add('preview-element', 'preview-shape');
                     shapeElement.style.left = s.pos.x;
                     shapeElement.style.top = s.pos.y;
                     shapeElement.style.width = s.pos.w;
                     shapeElement.style.height = s.pos.h;

                     if (s.data) {
                         // å¡«å……
                         if (s.data.fill && s.data.fill.type === 'solid' && s.data.fill.color) {
                             shapeElement.style.backgroundColor = `#${s.data.fill.color}`;
                         }
                         // è¾¹æ¡†
                         if (s.data.line) {
                             const width = s.data.line.width || 1;
                             const color = s.data.line.color || '000000';
                             // ç®€åŒ– dashType
                             const style = s.data.line.dashType ? 'dashed' : 'solid';
                             shapeElement.style.border = `${width}px ${style} #${color}`;
                         }
                         // åœ†è§’ (ä»…å¯¹ rect æœ‰æ•ˆ)
                         if (s.type === 'rect' && s.data.rectRadius !== undefined) {
                              const radiusValue = parseFloat(s.pos.w) * s.data.rectRadius; // ç®€åŒ–è®¡ç®—
                              shapeElement.style.borderRadius = `${radiusValue}%`;
                         }
                         // æ—‹è½¬
                         if (s.data.rotate) {
                             shapeElement.style.transform = `rotate(${s.data.rotate}deg)`;
                             shapeElement.style.transformOrigin = 'center';
                         }
                     }
                     previewElement.appendChild(shapeElement);
                 } else if(shapeElement) { // Append line element
                      shapeElement.classList.add('preview-element', 'preview-shape');
                      shapeElement.style.position = 'absolute';
                      shapeElement.style.left = s.pos.x;
                      shapeElement.style.top = s.pos.y;
                       previewElement.appendChild(shapeElement);
                 }
            });
        }

        // æ¸²æŸ“ Image
        if (slideData.image && Array.isArray(slideData.image)) {
            slideData.image.forEach(img => {
                // ä»…å¤„ç†æœ¬åœ°æˆ–åŒæºå›¾ç‰‡ï¼Œè¿œç¨‹å›¾ç‰‡éœ€è¦å¤„ç† CORS
                if (img.type === 'remote' || !img.type) { // å‡è®¾é»˜è®¤æ˜¯ remote/æœ¬åœ°è·¯å¾„
                    const imgElement = document.createElement('img');
                    imgElement.classList.add('preview-element', 'preview-image');
                    imgElement.src = img.data; // è®¾ç½®å›¾ç‰‡è·¯å¾„
                    imgElement.style.left = img.pos.x;
                    imgElement.style.top = img.pos.y;
                    imgElement.style.width = img.pos.w;
                    imgElement.style.height = img.pos.h;
                    // object-fit: contain å·²åœ¨ CSS ä¸­è®¾ç½®
                    previewElement.appendChild(imgElement);
                }
            });
        }

        // Chart æ¸²æŸ“éå¸¸å¤æ‚ï¼Œè¿™é‡Œä»…åšå ä½ç¬¦ç¤ºæ„
        if (slideData.chart && Array.isArray(slideData.chart)) {
             slideData.chart.forEach((c, index) => {
                 const chartPlaceholder = document.createElement('div');
                 chartPlaceholder.classList.add('preview-element');
                 chartPlaceholder.textContent = `[å›¾è¡¨: ${c.type}]`;
                 chartPlaceholder.style.left = c.pos.x;
                 chartPlaceholder.style.top = c.pos.y;
                 chartPlaceholder.style.width = c.pos.w;
                 chartPlaceholder.style.height = c.pos.h;
                 chartPlaceholder.style.display = 'flex';
                 chartPlaceholder.style.justifyContent = 'center';
                 chartPlaceholder.style.alignItems = 'center';
                 chartPlaceholder.style.backgroundColor = '#e9ecef';
                 chartPlaceholder.style.border = '1px dashed #6c757d';
                 chartPlaceholder.style.color = '#6c757d';
                 previewElement.appendChild(chartPlaceholder);
             });
        }

		// æ¸²æŸ“ Text
        if (slideData.text && Array.isArray(slideData.text)) {
            slideData.text.forEach(t => {
                const textDiv = document.createElement('div');
                textDiv.classList.add('preview-element', 'preview-text');
                textDiv.textContent = t.text;
                textDiv.style.left = t.pos.x;
                textDiv.style.top = t.pos.y;
                textDiv.style.width = t.pos.w;
                textDiv.style.height = t.pos.h;

                if (t.data) {
                    if (t.data.color) textDiv.style.color = `#${t.data.color}`;
                    if (t.data.fontSize) textDiv.style.fontSize = `${t.data.fontSize}px`;
                    if (t.data.bold) textDiv.style.fontWeight = 'bold';
                    if (t.data.italic) textDiv.style.fontStyle = 'italic';
                    // ç®€åŒ–å¤„ç† align
                    if (t.data.align) {
                         if(t.data.align === 'center') {
                             textDiv.style.justifyContent = 'center';
                             textDiv.style.textAlign = 'center';
                         } else if (t.data.align === 'right') {
                              textDiv.style.justifyContent = 'flex-end';
                              textDiv.style.textAlign = 'right';
                         } else {
                              textDiv.style.justifyContent = 'flex-start';
                              textDiv.style.textAlign = 'left';
                         }
                    }
                    if (t.data.margin !== undefined) {
                        textDiv.style.padding = `${t.data.margin}px`;
                    }
                    // rotate éœ€è¦æ›´å¤æ‚çš„CSSå¤„ç†ï¼Œè¿™é‡Œç®€åŒ–
                    if (t.data.rotate) {
                        textDiv.style.transform = `rotate(${t.data.rotate}deg)`;
                        textDiv.style.transformOrigin = 'center';
                    }
                    if (t.data.fill) {
                         textDiv.style.backgroundColor = `#${t.data.fill}`;
                    }
                }
                previewElement.appendChild(textDiv);
            });
        }
		
    }


    // --- äº‹ä»¶å¤„ç† ---
    confirmButton.addEventListener('click', () => {
        try {
            const jsonData = JSON.parse(jsonEditorElement.value);
            slides[currentSlideIndex] = jsonData;
            showSlide(currentSlideIndex); // æ›´æ–°é¢„è§ˆ
            // alert('ä¿®æ”¹å·²ç¡®è®¤å¹¶åº”ç”¨äºå½“å‰å¹»ç¯ç‰‡ã€‚');
        } catch (e) {
            alert('JSONæ ¼å¼é”™è¯¯: ' + e.message);
        }
    });
	
	deleteButton.addEventListener('click', () => {
        if (slides.length <= 1) {
            alert('è‡³å°‘éœ€è¦ä¿ç•™ä¸€å¼ å¹»ç¯ç‰‡ã€‚');
            return;
        }
        if (confirm(`ç¡®å®šè¦åˆ é™¤å¹»ç¯ç‰‡ ${currentSlideIndex + 1} å—?`)) {
            slides.splice(currentSlideIndex, 1);
            // è°ƒæ•´å½“å‰ç´¢å¼•
            if (currentSlideIndex >= slides.length) {
                currentSlideIndex = slides.length - 1;
            }
            
            updateSlideList();
            showSlide(currentSlideIndex);
			jsonEditorElement.value = JSON.stringify(slides[currentSlideIndex], null, 2);
        }
	});

    newSlideButton.addEventListener('click', () => {
        slides.push({ text: [], image: [], shape: [], chart: [] }); // æ·»åŠ ä¸€ä¸ªç©ºå¹»ç¯ç‰‡
        currentSlideIndex = slides.length - 1;
        updateSlideList();
        showSlide(currentSlideIndex);
        jsonEditorElement.value = JSON.stringify(slides[currentSlideIndex], null, 2);
    });

    exportButton.addEventListener('click', () => {
        exportPPTX();
    });
	
	helpButton.addEventListener('click', async () => {
		const clipboardObj = navigator.clipboard;
		try {
			await navigator.clipboard.writeText(document.getElementById("reference-prompt-store").innerText);
			alert("æç¤ºè¯å·²å­˜è‡³å‰ªè´´æ¿ï¼Œç²˜è´´è‡³å¤§è¯­è¨€æ¨¡å‹å³å¯å¿«é€Ÿå¼€å§‹ç”Ÿæˆã€‚");
		} catch (err) {
			alert("æç¤ºè¯å¤åˆ¶å¤±è´¥ï¼Œè¯·æ›´æ¢è‡³æœ€æ–°çš„æµè§ˆå™¨å†è¯•ã€‚");
		}
    });


    // --- PPTX å¯¼å‡ºæ ¸å¿ƒå‡½æ•° ---
    async function exportPPTX() {
        try {
            // --- å…³é”®ä¿®æ”¹ï¼šä½¿ç”¨æ­£ç¡®çš„å…¨å±€æ„é€ å‡½æ•° ---
            // æ£€æŸ¥ PptxGenJS æ˜¯å¦å­˜åœ¨
            if (typeof PptxGenJS === 'undefined') {
                alert('PPTXç”Ÿæˆåº“åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•ã€‚');
                console.error('PptxGenJS is not defined. Check the script loading.');
                return;
            }

            // ä½¿ç”¨ PptxGenJS æ„é€ å‡½æ•°åˆ›å»ºå®ä¾‹
            const pptx = new PptxGenJS(); // <-- ä¿®æ”¹ç‚¹ 1: ä½¿ç”¨ PptxGenJS
            // --- ä¿®æ”¹ç»“æŸ ---

            for (const slideData of slides) {
                const slide = pptx.addSlide();
				
                // æ·»åŠ  Shape
                if (slideData.shape && Array.isArray(slideData.shape)) {
                    for (const s of slideData.shape) {
                        const options = {
                            x: s.pos.x,
                            y: s.pos.y,
                            w: s.pos.w,
                            h: s.pos.h,
                            fill: s.data?.fill?.color ? { color: s.data.fill.color } : undefined,
                            line: s.data?.line ? { color: s.data.line.color, width: s.data.line.width, dashType: s.data.line.dashType } : undefined,
                            rectRadius: s.type === 'rect' ? s.data?.rectRadius : undefined,
                            rotate: s.data?.rotate
                        };
                        Object.keys(options).forEach(key => (options[key] === undefined || options[key] === null) && delete options[key]);

                        // æ˜ å°„ shape ç±»å‹
                        let pptxShapeType = pptx.ShapeType.rect; // <-- ä¿®æ”¹ç‚¹ 3: ä½¿ç”¨ pptx.ShapeType
                        if (s.type === 'ellipse') pptxShapeType = pptx.ShapeType.ellipse;
                        else if (s.type === 'line') pptxShapeType = pptx.ShapeType.line;

                        slide.addShape(pptxShapeType, options);
                    }
                }

                 // æ·»åŠ  Image
                if (slideData.image && Array.isArray(slideData.image)) {
                    for (const img of slideData.image) {
                        if (img.type === 'remote' || !img.type) {
                            const options = {
                                x: img.pos.x,
                                y: img.pos.y,
                                w: img.pos.w,
                                h: img.pos.h,
                                path: img.data // å¯¹äºæœ¬åœ°/åŒæºæ–‡ä»¶è·¯å¾„
                                // å¦‚æœæ˜¯ base64: data: "data:image/...;base64,..."
                                // å¦‚æœæ˜¯è¿œç¨‹URLï¼Œéœ€è¦ç¡®ä¿CORSå…è®¸æˆ–å…ˆè½¬æ¢ä¸ºblob/base64
                            };
                            Object.keys(options).forEach(key => (options[key] === undefined || options[key] === null) && delete options[key]);
                            
                            try {
                                // addImage é€šå¸¸ä¸è¿”å› Promise, ä½†å¤„ç†å¯èƒ½éœ€è¦æ—¶é—´
                                slide.addImage(options);
                            } catch (imgErr) {
                                 console.error("æ·»åŠ å›¾ç‰‡æ—¶å‡ºé”™:", imgErr);
                                 // å¯ä»¥é€‰æ‹©è·³è¿‡æˆ–æç¤º
                            }
                        }
                    }
                }

                // æ·»åŠ  Chart
                if (slideData.chart && Array.isArray(slideData.chart)) {
                    for (const c of slideData.chart) {
                         const chartData = [{
                              name: c.data?.name || 'Series',
                              labels: c.data?.labels || [],
                              values: c.data?.values || []
                         }];

                         // æ˜ å°„å›¾è¡¨ç±»å‹
                         let chartType = pptx.ChartType.bar; // é»˜è®¤
                         const typeMap = {
                             'area': pptx.ChartType.area,
                             'bar': pptx.ChartType.bar,
                             'bar3d': pptx.ChartType.bar3D,
                             'bubble': pptx.ChartType.bubble,
                             'bubble3d': pptx.ChartType.bubble3D,
                             'doughnut': pptx.ChartType.doughnut,
                             'line': pptx.ChartType.line,
                             'pie': pptx.ChartType.pie,
                             'radar': pptx.ChartType.radar,
                             'scatter': pptx.ChartType.scatter
                         };
                         if (typeMap[c.type]) {
                             chartType = typeMap[c.type];
                         }

                         const options = {
                              x: c.pos.x,
                              y: c.pos.y,
                              w: c.pos.w,
                              h: c.pos.h,
                              type: chartType
                         };
                         Object.keys(options).forEach(key => (options[key] === undefined || options[key] === null) && delete options[key]);

                         slide.addChart(chartType, chartData, options);
                    }
                }
				
				// æ·»åŠ  Text
                if (slideData.text && Array.isArray(slideData.text)) {
                    for (const t of slideData.text) {
                        const options = {
                            x: t.pos.x,
                            y: t.pos.y,
                            w: t.pos.w,
                            h: t.pos.h,
                            fontSize: t.data?.fontSize,
                            bold: t.data?.bold,
                            italic: t.data?.italic,
                            color: t.data?.color ? `#${t.data.color}` : undefined, // <-- ä¿®æ”¹ç‚¹ 2: ç¡®ä¿é¢œè‰²æ ¼å¼æ­£ç¡® (æ·»åŠ  #)
                            fill: t.data?.fill ? `#${t.data.fill}` : undefined,     // <-- ä¿®æ”¹ç‚¹ 2: ç¡®ä¿å¡«å……æ ¼å¼æ­£ç¡® (æ·»åŠ  #)
                            align: t.data?.align,
                            margin: t.data?.margin,
                            rotate: t.data?.rotate // pptxgenjs æ”¯æŒ rotate
                        };
                        Object.keys(options).forEach(key => (options[key] === undefined || options[key] === null) && delete options[key]);
                        
                        // å¤„ç†æ–‡æœ¬å¯¹é½ (pptxgenjs ä½¿ç”¨ 'ctr', 'l', 'r', 'just')
                        if (options.align) {
                            const alignMap = { 'left': 'l', 'center': 'ctr', 'right': 'r' };
                            options.align = alignMap[options.align] || options.align;
                        }
                        
                        slide.addText(t.text, options);
                    }
                }

            }

            // è§¦å‘ä¸‹è½½
            pptx.writeFile({ fileName: "ç”Ÿæˆçš„æ¼”ç¤ºæ–‡ç¨¿.pptx" });
        } catch (error) {
            console.error("å¯¼å‡ºPPTXæ—¶å‘ç”Ÿé”™è¯¯:", error);
            alert("å¯¼å‡ºå¤±è´¥: " + error.message);
        }
    }

    // å¯åŠ¨åº”ç”¨
    window.onload = init;
</script>

</body>
</html>